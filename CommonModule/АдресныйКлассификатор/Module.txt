// Проверяет наличие обновлений адресного классификатора на веб сервере
// для тех объектов, которые ранее уже загружались (для тех объектов
// для которых есть запись в регистре ВерсииОбъектовАдресногоКлассификатора).
//
// Возвращаемое значение
// Массив структур, в котором каждая структура имеет формат:
// ключ КодАдресногоОбъекта - строка - код адресного объекта
// ключ Наименование       - строка - наименование адресного объекта
// ключ Сокращение         - строка - сокращение адресного объекта
// ключ Индекс             - строка - индекс адресного объекта
// ключ ОбновлениеДоступно - Булево
//
Функция ПроверитьОбновлениеАдресныхОбъектов_Сервер() Экспорт
	
	Возврат АдресныйКлассификаторКлиентСервер.ПроверитьОбновлениеАдресныхОбъектов();
	
КонецФункции

// Возвращает версию адресных объектов, записанную при последнем обновлении
// Если записи об адресном объекте нет - возвращается дата 01.09.2008
// Возвращаемое значение
// Массив соответствий: ключ - номер адресного объекта, значение - дата выпуска версии
//
Функция ПолучитьВерсииАдресныхОбъектов() Экспорт
	
	Запрос = Новый Запрос;
	Запрос.Текст = "Выбрать АдресныйОбъект, ДатаВыпускаВерсии
	               |ИЗ РегистрСведений.ВерсииОбъектовАдресногоКлассификатора";
	
	ВыборкаЗапроса = Запрос.Выполнить().Выбрать();
	
	Результат = Новый Соответствие;
	
	Пока ВыборкаЗапроса.Следующий() Цикл
		Результат.Вставить(ВыборкаЗапроса.АдресныйОбъект, ВыборкаЗапроса.ДатаВыпускаВерсии);
	КонецЦикла;
	
	Возврат Результат;
	
КонецФункции

//////////////////////////////////////////////////////////////////////////////// 
// Блок экспортных функций, реализующих загрузку и очистку адресных сведений
// в регистре сведений АдресныйКлассификатор
//

// Процедура для загрузки данных в КЛАДР
//
// Параметры:
// КодАдресногоОбъекта- строка - код адресного объекта в формате NN
// ПутьКДаннымНаСервере - Строка - путь к каталогу на сервере, в котором хранятся файлы кладр
// ЗагрузкаСВеб    - булево - если Истина, данные загружаются с веб сервера 1С
//
Процедура ЗагрузитьКлассификаторПоАдресномуОбъекту(знач КодАдресногоОбъекта,
                                                   ПутьКДаннымНаСервере,
                                                   ЗагрузкаСВеб) Экспорт
	
	КодАдресногоОбъекта = Лев(КодАдресногоОбъекта, 2);
	
	АльтернативныеНазвания = Новый ТаблицаЗначений;
	АльтернативныеНазвания.Колонки.Добавить("Код");
	АльтернативныеНазвания.Колонки.Добавить("Наименование");
	АльтернативныеНазвания.Колонки.Добавить("Сокращение");
	АльтернативныеНазвания.Колонки.Добавить("Индекс");
	
	АдресныеСведения = Новый ТаблицаЗначений;
	АдресныеСведения.Колонки.Добавить("Код");
	АдресныеСведения.Колонки.Добавить("КодАдресногоОбъектаВКоде");
	АдресныеСведения.Колонки.Добавить("Наименование");
	АдресныеСведения.Колонки.Добавить("АльтернативныеНазвания");
	АдресныеСведения.Колонки.Добавить("Сокращение");
	АдресныеСведения.Колонки.Добавить("Индекс");
	АдресныеСведения.Колонки.Добавить("ТипАдресногоЭлемента");
	АдресныеСведения.Колонки.Добавить("КодРайонаВКоде");
	АдресныеСведения.Колонки.Добавить("КодГородаВКоде");
	АдресныеСведения.Колонки.Добавить("КодНаселенногоПунктаВКоде");
	АдресныеСведения.Колонки.Добавить("КодУлицыВКоде");
	
	Постфикс = ? (ЗагрузкаСВеб, КодАдресногоОбъекта, "");
	
	ЗагрузитьАдресныеСведения(КодАдресногоОбъекта,
	                          ПутьКДаннымНаСервере + "kladr"+Постфикс,
	                          АдресныеСведения,
	                          АльтернативныеНазвания);
	
	ЗагрузитьАдресныеСведения(КодАдресногоОбъекта,
	                           ПутьКДаннымНаСервере + "street"+Постфикс,
	                           АдресныеСведения,
	                           АльтернативныеНазвания,
	                           5);
	
	ЗагрузитьАдресныеСведения(КодАдресногоОбъекта,
	                          ПутьКДаннымНаСервере + "doma"+Постфикс,
	                          АдресныеСведения,
	                          АльтернативныеНазвания,
	                          6);
	
	Файл = Новый Файл(ПутьКДаннымНаСервере+"altnames.dbf");
	
	Если Файл.Существует() Тогда
		ЗаполнитьАльтернативныеНазвания(ПутьКДаннымНаСервере, АдресныеСведения, АльтернативныеНазвания);
	КонецЕсли;
	
	ЗаписатьКлассификатор(КодАдресногоОбъекта, АдресныеСведения);
	
КонецПроцедуры

// Процедура очищает адресные сведений по переданным адресным объектам.
// 
// Параметры
// МассивАдресныхОбъектов - массив - каждый элемент - строка, номер
//                          адресного объекта в формате NN
//
Процедура УдалитьАдресныеСведения(знач МассивАдресныхОбъектов) Экспорт
	
	Для Каждого КодАдресногоОбъекта Из МассивАдресныхОбъектов Цикл
		НаборАдресныхСведений = РегистрыСведений.АдресныйКлассификатор.СоздатьНаборЗаписей();
		НаборАдресныхСведений.Отбор.КодАдресногоОбъектаВКоде.Использование = Истина;
		НаборАдресныхСведений.Отбор.КодАдресногоОбъектаВКоде.Значение = Число(КодАдресногоОбъекта);
		НаборАдресныхСведений.Записать();
		УстановитьВерсиюКлассификатора(КодАдресногоОбъекта);
	КонецЦикла;
	
КонецПроцедуры

// Функция возвращает число адресных объектов по которым заполнены адресные сведения
//
Функция ЧислоЗаполненныхАдресныхОбъектов() Экспорт
	
	ТекстЗапроса =  "ВЫБРАТЬ
					|	Истина
					|ИЗ
					|	РегистрСведений.АдресныйКлассификатор КАК АдресныйКлассификатор
					|
					|СГРУППИРОВАТЬ ПО
					|	АдресныйКлассификатор.КодАдресногоОбъектаВКоде
					|
					|ИМЕЮЩИЕ
					|	КОЛИЧЕСТВО(АдресныйКлассификатор.КодАдресногоОбъектаВКоде) <> 1";
	
	Запрос = Новый Запрос;
	Запрос.Текст = ТекстЗапроса;
	
	Возврат Запрос.Выполнить().Выбрать().Количество();
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Блок функций первоначального заполнения и обновления ИБ
//

// Добавляет в список Обработчики процедуры-обработчики обновления,
// необходимые данной подсистеме.
//
// Параметры:
//   Обработчики - ТаблицаЗначений - см. описание функции НоваяТаблицаОбработчиковОбновления
//                                   общего модуля ОбновлениеИнформационнойБазы.
// 
Процедура ЗарегистрироватьОбработчикиОбновления(Обработчики) Экспорт
	
	Обработчик = Обработчики.Добавить();
	Обработчик.Версия = "1.0.1.1";
	Обработчик.Процедура = "АдресныйКлассификатор.ЗагрузитьАдресныеОбъектыПервогоУровня";
	
КонецПроцедуры	

// Загружает адресные объекты первого уровня по макету
//
Процедура ЗагрузитьАдресныеОбъектыПервогоУровня() Экспорт
	
	КлассификаторАдресныхОбъектовXML = РегистрыСведений.АдресныйКлассификатор.ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст();
	
	КлассификаторТаблица = ОбщегоНазначения.ПрочитатьXMLВТаблицу(КлассификаторАдресныхОбъектовXML).Данные;
	
	Для Каждого АдресныйОбъект Из КлассификаторТаблица Цикл
		
		МенеджерЗаписи = РегистрыСведений.АдресныйКлассификатор.СоздатьМенеджерЗаписи();
		
		МенеджерЗаписи.Код                  = АдресныйОбъект.Code;
		МенеджерЗаписи.ТипАдресногоЭлемента = 1;
		МенеджерЗаписи.Наименование         = АдресныйОбъект.Name;
		МенеджерЗаписи.Сокращение           = АдресныйОбъект.Socr;
		МенеджерЗаписи.Индекс               = АдресныйОбъект.Index;
		МенеджерЗаписи.КодАдресногоОбъектаВКоде      = Лев(АдресныйОбъект.Code,2);
		
		МенеджерЗаписи.Записать();
		
	КонецЦикла;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// Блок сервисных функций, используются при загрузке адресного классификатора
//

// Загружает адресные сокращения в регистр АдресныеСокращения.
// Параметры
// ПутьКДаннымНаСервере - путь к каталогу в котором находится файл socrbase.dbf
// Возвращаемое значение
// булево - истина - сведения успешно записаны
//          ложь - ошибка при подготовке / записи сведений в регистр
//
Функция ЗагрузитьАдресныеСокращения(ПутьКДаннымНаСервере) Экспорт
	
	ФайлАдресныхСокращений = ПутьКДаннымНаСервере +  "socrbase.dbf";
	
	ТаблицаАдресныеСокращения = Новый ТаблицаЗначений;
	ТаблицаАдресныеСокращения.Колонки.Добавить("Код");
	ТаблицаАдресныеСокращения.Колонки.Добавить("Уровень");
	ТаблицаАдресныеСокращения.Колонки.Добавить("Наименование");
	ТаблицаАдресныеСокращения.Колонки.Добавить("Сокращение");
	
	АдресныеСокращения = РегистрыСведений.АдресныеСокращения;
	
	НаборЗаписей = АдресныеСокращения.СоздатьНаборЗаписей();
	НаборЗаписей.Записать();
	
	xB = Новый XBase(ФайлАдресныхСокращений);
	xB.Кодировка = КодировкаXBase.OEM;
	
	// Контроль уникальности кодов в файле классификатора
	Контроль = Новый Соответствие;
	ЕстьОшибки = Ложь;
	Если xB.Открыта() Тогда
		Пока Не xB.ВКонце() Цикл
			КодУникальности = Число(xB.level)*10000 + Число(xB.kod_t_st);
			Если Контроль[КодУникальности] = НеОпределено Тогда
				Контроль[КодУникальности] = 0;
				НоваяЗапись = НаборЗаписей.Добавить();
				НоваяЗапись.Код           = xB.kod_t_st;
				НоваяЗапись.Уровень       = xB.level;
				НоваяЗапись.Наименование  = xB.socrname;
				НоваяЗапись.Сокращение    = xB.scname;
			Иначе
				ЕстьОшибки = Истина;
			КонецЕсли;
			xB.Следующая();
			
		КонецЦикла;
		xB.ЗакрытьФайл();
	Иначе
		Возврат Ложь;
	КонецЕсли;
	
	Если ЕстьОшибки Тогда
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Адресный классификатор.Загрузка'"), 
			УровеньЖурналаРегистрации.Ошибка,,, 
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В файле адресного классификатора %1 есть ошибки уникальности кодов'"),
			"socrbase.dbf"));
	КонецЕсли;
	НаборЗаписей.Записать();
	
	Возврат Истина;
	
КонецФункции

// Функция для заполнения данных с 2-го по 6-й уровень классификации:
// 2-й - районы (улусы) республик, краев, областей, автономных областей,
//       автономных округов, входящих в состав Российской Федерации.
// 3-й   города и поселки городского типа1 регионального и районного подчинения;
//       сельсоветы (сельские округа, сельские администрации, волости и т.п.).
// 4-й   города и поселки городского типа , подчиненные администрациям городов третьего уровня;
//       сельские населенные пункты
// 5-й   улицы городов, поселков городского типа и сельских населенных пунктов.
// 6-й   дома, расположенные в городах и поселках городского типа, являющихся объектами
//       третьего уровня , в т.ч. дома, непосредственно привязанные к городам и поселкам
//       городского типа
//
// Параметры:
// КодАдресногоОбъекта  - строка (2 символа) - строковое представление номера адресного объекта
// ПутьКДаннымНаСервере - Строка - путь к каталогу на сервере, в котором 
//                 хранятся файлы кладр. Путь заканчивается слешем (обратным или прямым)
// АдресныеСведения - ТаблицаЗначений - таблица, которая заполняется загружаемыми элементами
// АльтернативныеНазвания
// ТипАдресногоЭлемента - число - по сути уровень адресного объекта
//
Функция ЗагрузитьАдресныеСведения(КодАдресногоОбъекта,
                                  ПутьКДаннымНаСервере,
                                  АдресныеСведения,
                                  АльтернативныеНазвания,
                                  знач ТипАдресногоЭлемента = Неопределено)
	
	ФайлАдресногоКлассификатора = ПутьКДаннымНаСервере +  ".dbf";
	ФайлИндексаКлассификатора   = ПутьКДаннымНаСервере +  ".cdx";
	
	ФайлИндекса = Новый Файл (ФайлИндексаКлассификатора);
	Если НЕ ФайлИндекса.Существует() Тогда
		xB = Новый XBase(ФайлАдресногоКлассификатора);
		xB.Кодировка = КодировкаXBase.OEM;
		
		Если xB.Открыта() Тогда
			// Для загрузки сразу группы адресных сведений удобно
			// пользоваться индексом по всему поле CODE
			xB.индексы.Добавить("IDXCODE", "CODE", Истина);
			xB.СоздатьИндексныйФайл(ФайлИндексаКлассификатора);
			xB.ЗакрытьФайл();
		Иначе
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	xB = Новый XBase(ФайлАдресногоКлассификатора,
	                 ФайлИндексаКлассификатора,
	                 Истина);
	xB.Кодировка = КодировкаXBase.OEM;
	
	// Если мы загружаем улицы или дома, то
	// тип адресного элемента
	Если ТипАдресногоЭлемента <> Неопределено Тогда
		ТипАдресногоЭлементаУстановлен = Истина;
	Иначе
		ТипАдресногоЭлементаУстановлен = Ложь;
	КонецЕсли;
	
	Если Не xB.Открыта() Тогда
		Возврат Ложь;
	КонецЕсли;
		
	Контроль = Новый Соответствие;
	ЕстьОшибки = Ложь;
	
	xB.ТекущийИндекс = xB.Индексы.Найти("IDXCODE");
	
	xB.Найти (КодАдресногоОбъекта, "=");
	
	Пока Не xB.ВКонце() Цикл
		Код = xB.CODE;
		
		Если Контроль[Код] = НеОпределено Тогда
			Контроль[Код] = 0;
			
			Если Лев(Код, 2) <> КодАдресногоОбъекта Тогда
				Прервать;
			КонецЕсли;
			
			Если НЕ ТипАдресногоЭлементаУстановлен Тогда
				ТипАдресногоЭлемента = ПолучитьТипАдресногоЭлементаПоКоду(Код);
			КонецЕсли;
			
			// Если это альтернативное название, то заносим сведения в отдельную таблицу
			// альтернативных наименований (для номеров домов альтернативных наименований нет)
			ПризнакАктуальности = Прав(Код, 2);
			Если  (ТипАдресногоЭлемента <> 6)
				И (ПризнакАктуальности <> "00")
				И (ПризнакАктуальности <> "99") Тогда
				
				СтрокаАльтернативныхНазваний = АльтернативныеНазвания.Добавить();
				СтрокаАльтернативныхНазваний.Код          = Код;
				СтрокаАльтернативныхНазваний.Наименование = СокрЛП(xB.NAME);
				СтрокаАльтернативныхНазваний.Сокращение   = СокрЛП(xB.SOCR);
				СтрокаАльтернативныхНазваний.Индекс       = СокрЛП(xB.INDEX);
				
				xB.Следующая();
				Продолжить;
				
			КонецЕсли;
			
			НоваяСтрока = АдресныеСведения.Добавить();
			
			НоваяСтрока.Код = Код;
			
			НоваяСтрока.ТипАдресногоЭлемента      = ТипАдресногоЭлемента;
			НоваяСтрока.КодАдресногоОбъектаВКоде           = Число(Сред(Код, 1, 2));
			НоваяСтрока.КодРайонаВКоде            = Число(Сред(Код, 3, 3));
			НоваяСтрока.КодГородаВКоде            = Число(Сред(Код, 6, 3));
			НоваяСтрока.КодНаселенногоПунктаВКоде = Число(Сред(Код, 9, 3));
			НоваяСтрока.КодУлицыВКоде             = Число(Сред(Код, 12, 4));
			
			НоваяСтрока.Наименование = СокрЛП(xB.NAME);
			НоваяСтрока.Индекс       = xB.INDEX;
			НоваяСтрока.Сокращение   = СокрЛП(xB.SOCR);
			
			xB.Следующая();
		Иначе
			ЕстьОшибки = Истина;
		КонецЕсли;
		
	КонецЦикла;
	
	xB.ЗакрытьФайл();
	
	Если ЕстьОшибки Тогда
		ЗаписьЖурналаРегистрации(НСтр("ru = 'Адресный классификатор.Загрузка'"), 
			УровеньЖурналаРегистрации.Ошибка, , ,
			СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru = 'В файле адресного классификатора %1 есть ошибки уникальности кодов'"),
			ПутьКДаннымНаСервере));
	КонецЕсли;
	
	Возврат Истина;
	
КонецФункции

// Дополняет адресные сведения альтернативными названиями
//
Функция ЗаполнитьАльтернативныеНазвания(ПутьКДаннымНаСервере,
                                        АдресныеСведения,
                                        АльтернативныеНазвания)
	
	ПутьКФайлуАН        = ПутьКДаннымНаСервере + "altnames.dbf";
	ПутьКФайлуАН_Индекс = ПутьКДаннымНаСервере + "altnames.cdx";
	
	ФайлИндекса = Новый Файл (ПутьКФайлуАН_Индекс);
	Если НЕ ФайлИндекса.Существует() Тогда
		xB = Новый XBase(ПутьКФайлуАН);
		xB.Кодировка = КодировкаXBase.OEM;
		Если xB.Открыта() Тогда
			xB.индексы.Добавить("IDXCODE", "OLDCODE", Истина);
			xB.СоздатьИндексныйФайл(ПутьКФайлуАН_Индекс);
			xB.ЗакрытьФайл();
		Иначе
			Возврат Ложь;
		КонецЕсли;
	КонецЕсли;
	
	xB = Новый XBase(ПутьКФайлуАН,
	                 ПутьКФайлуАН_Индекс,
	                 Истина);
	
	xB.Кодировка = КодировкаXBase.OEM;
	
	Если xB.Открыта() Тогда
		xB.ТекущийИндекс = xB.Индексы.Найти("IDXCODE");
	КонецЕсли;
	
	Для Каждого АльтернативныйОбъект Из АльтернативныеНазвания Цикл
		
		ПризнакАктуальности = Прав(АльтернативныйОбъект.Код, 2);
		
		КодАктуальногоНаименования = Лев(АльтернативныйОбъект.Код,
		                                 СтрДлина(АльтернативныйОбъект.Код) - 2) + "00";
		
		Если ПризнакАктуальности = "51" Тогда
			// адресную информацию необходимо искать в altnames.dbf
			OLDCODE = КодАктуальногоНаименования;
			xB.Найти (OLDCODE, "=");
			
			НовыйКод = СокрЛП(xB.NewCode);
			
			// пытаемся найти актуальный объект в адресных сведениях
			СтрокаТаблицы = АдресныеСведения.Найти(НовыйКод, "Код");
			
			Если СтрокаТаблицы = Неопределено Тогда
				
				КодУдаленногоНП = Лев(АльтернативныйОбъект.Код, 
				                      СтрДлина(АльтернативныйОбъект.Код) - 2) + "99";
				
				НоваяСтрока = АдресныеСведения.Добавить();
				
				Код = Лев(АльтернативныйОбъект.Код, СтрДлина(АльтернативныйОбъект.Код) - 2) + "00";
				
				ТипАдресногоЭлемента = ПолучитьТипАдресногоЭлементаПоКоду(Код);
				
				НоваяСтрока.Код = Код;
				
				НоваяСтрока.ТипАдресногоЭлемента      = ТипАдресногоЭлемента;
				НоваяСтрока.КодАдресногоОбъектаВКоде           = Число(Сред(Код, 1, 2));
				НоваяСтрока.КодРайонаВКоде            = Число(Сред(Код, 3, 3));
				НоваяСтрока.КодГородаВКоде            = Число(Сред(Код, 6, 3));
				НоваяСтрока.КодНаселенногоПунктаВКоде = Число(Сред(Код, 9, 3));
				НоваяСтрока.КодУлицыВКоде             = Число(Сред(Код, 12, 4));
				
				НоваяСтрока.Наименование = СокрЛП(АльтернативныйОбъект.Наименование);
				НоваяСтрока.Индекс       = СокрЛП(АльтернативныйОбъект.Индекс);
				НоваяСтрока.Сокращение   = СокрЛП(АльтернативныйОбъект.Сокращение);
				
				Продолжить;
			КонецЕсли;
			
		Иначе
			
			СтрокаТаблицы = АдресныеСведения.Найти(КодАктуальногоНаименования, "Код");
			
		КонецЕсли; // Если ПризнакАктуальности = "51" Тогда ... Иначе
		
		
		Если СтрокаТаблицы <> Неопределено Тогда
			Если ЗначениеЗаполнено(СокрЛП(АльтернативныйОбъект.Индекс)) Тогда 
				ИндексААО = " : " + АльтернативныйОбъект.Индекс;
			Иначе
				ИндексААО = "";
			КонецЕсли;
			
			АльтернативноеНазвание = АльтернативныйОбъект.Наименование
			                        + " "
			                        + АльтернативныйОбъект.Сокращение
			                        + ИндексААО;
			
			Если СтрокаТаблицы.АльтернативныеНазвания = Неопределено Тогда
				СтрокаТаблицы.АльтернативныеНазвания = АльтернативноеНазвание;
			Иначе
				СтрокаТаблицы.АльтернативныеНазвания =  СтрокаТаблицы.АльтернативныеНазвания
				                                        + ", "
				                                        + АльтернативноеНазвание;
			КонецЕсли;
		КонецЕсли; // Если СтрокаТаблицы <> Неопределено Тогда
		
		СтрокаТаблицы = Неопределено;
		
	КонецЦикла;
	
	Если xB.Открыта() Тогда
		xB.ЗакрытьФайл();
	КонецЕсли;
	
КонецФункции

// Функция для заполнения данных с 2-го по 4-й уровень классификации:
//
// Параметры:
// КодАдресногоОбъекта - строка - код адресного объекта в формате NN
// АдресныеСведения - ТаблицаЗначений - записи, повторяющие структуру РС АдресныйКлассификатор;
//                    которые переносятся в регистр
//
Функция ЗаписатьКлассификатор(КодАдресногоОбъекта, АдресныеСведения)
	
	Для Каждого Элемент Из АдресныеСведения Цикл
		
		КодСтр = Строка(Элемент.Код);
		ДС = СтрДлина(КодСтр);
		
		Для Индекс = ДС По 20 Цикл
			КодСтр = КодСтр + "0";
		КонецЦикла;
		
		Элемент.Код = КодСтр;
		
	КонецЦикла;
	
	НаборАдресныхСведений = РегистрыСведений.АдресныйКлассификатор.СоздатьНаборЗаписей();
	НаборАдресныхСведений.Отбор.КодАдресногоОбъектаВКоде.Использование = Истина;
	НаборАдресныхСведений.Отбор.КодАдресногоОбъектаВКоде.Значение = Число(КодАдресногоОбъекта);
	НаборАдресныхСведений.Загрузить(АдресныеСведения);
	НаборАдресныхСведений.Записать();
	
КонецФункции

// Функция получает уровень адресного элемента (всего 6 уровней) в 
// иерархической системе классификации по его коду
// формат кода:
// _2__3___3___3___4____4____
// |СС|РРР|ГГГ|ППП|УУУУ|ДДДД|
// 
// чем глубже уровень иерархии тем более младшие разряды являются заполненными
//
// Параметры:
// Код           - строка - код, взятый из поля записи CODE файла данных
// 
// Возвращаемое значение:
// Число [1-6]
Функция ПолучитьТипАдресногоЭлементаПоКоду(знач Код)
	
	Размерность = СтрДлина(Код);
	
	// для кодов с размерностью 13 или 17 необходимо уменьшить код
	// на 2 разряда - символы актуальности адресного объекта
	Если Размерность = 13 ИЛИ Размерность = 17 Тогда
		Размерность = Размерность - 2;
		КодЧисло = Число(Сред(Код, 1, СтрДлина(Код)-2));
	ИначеЕсли Размерность = 19 Тогда
		КодЧисло = Число(Сред(Код, 1, СтрДлина(Код)));
	КонецЕсли;
	
	// Проверяем заполненность разрядов ДДДД
	Если Размерность = 19 Тогда
		
		Ост = КодЧисло % 10000;
		Если Ост <> 0 Тогда
			Возврат 6;
		КонецЕсли;
		
		КодЧисло = КодЧисло / 10000;
		
	КонецЕсли;
	
	// Проверяем заполненность разрядов УУУУ
	Если Размерность = 15 Тогда
		
		Ост = КодЧисло % 10000;
		Если Ост <> 0 Тогда
			Возврат 5;
		КонецЕсли;
		
		КодЧисло = КодЧисло / 10000;
		
	КонецЕсли;
	
	// Проверяем заполненность разрядов ППП
	Ост = КодЧисло % 1000;
	Если Ост <> 0 Тогда
		Возврат 4;
	КонецЕсли;
	
	// Проверяем заполненность разрядов ГГГ
	Ост = КодЧисло % 1000000;
		
	Если Ост <> 0 Тогда
		Возврат 3;
	КонецЕсли;
	
	// Проверяем заполненность разрядов РРР
	Ост = КодЧисло % 1000000000;
		
	Если Ост <> 0 Тогда
		Возврат 2;
	КонецЕсли;
	
	// Верхний уровень иерархии - единица
	
	Возврат 1;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функции для получении информации по адресным объектам
//

// Возвращает структуру, содержащую информацию по адресному объекту
// 
// Параметры
// КодАдресногоОбъекта - Строка - номер адресного объекта от 1 до 89 + 99 в формате NN
//
// Возвращаемое значение
// структура, с ключами: КодАдресногоОбъекта, Наименование, Сокращение, Индекс
//
Функция ИнформацияПоАдресномуОбъекту(КодАдресногоОбъекта) Экспорт
	
	КлассификаторАдресныхОбъектовXML = РегистрыСведений.АдресныйКлассификатор.ПолучитьМакет("КлассификаторАдресныхОбъектовРоссии").ПолучитьТекст();
	
	КлассификаторТаблица = ОбщегоНазначения.ПрочитатьXMLВТаблицу(КлассификаторАдресныхОбъектовXML).Данные;
	
	Результат = Новый Структура("КодАдресногоОбъекта, Наименование, Сокращение, Индекс");
	
	Для Каждого АдресныйОбъект Из КлассификаторТаблица Цикл
		Если Лев(АдресныйОбъект.Code, 2) = КодАдресногоОбъекта Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Результат.КодАдресногоОбъекта = АдресныйОбъект.Code;
	Результат.Наименование        = АдресныйОбъект.Name;
	Результат.Сокращение          = АдресныйОбъект.Socr;
	Результат.Индекс              = АдресныйОбъект.Index;
	
	Возврат Результат;
	
КонецФункции

////////////////////////////////////////////////////////////////////////////////
// Функция для работы с версиями сведений по адресным объектам
//

// Устанавливает версию адресного объекта в регистре
// Параметры
// НомерАО - строка - код адресного объекта в формате NN
// Наименование - наименование адресного объекта
// ВерсияСведенийПоАдресномуОбъекту - дата - версия адресного объекта
//
Процедура УстановитьВерсиюКлассификатора(знач НомерАО,
                                         знач Наименование = "",
                                         знач ВерсияСведенийПоАдресномуОбъекту = "") Экспорт
	
	МенеджерЗаписи = РегистрыСведений.ВерсииОбъектовАдресногоКлассификатора.СоздатьМенеджерЗаписи();
	
	Если ПустаяСтрока(ВерсияСведенийПоАдресномуОбъекту) Тогда
		МенеджерЗаписи.АдресныйОбъект = НомерАО;
		МенеджерЗаписи.Прочитать();
		МенеджерЗаписи.Удалить();
	Иначе
		МенеджерЗаписи.АдресныйОбъект = НомерАО;
		МенеджерЗаписи.ДатаВыпускаВерсии = ВерсияСведенийПоАдресномуОбъекту;
		МенеджерЗаписи.Наименование = Наименование;
		
		МенеджерЗаписи.Записать(Истина);
	КонецЕсли;
	
КонецПроцедуры

// Считывает с диска файл версий адресных объектов и возвращает
// версии сведений по адресным объектам
//
Функция ПолучитьВерсииАдресныхСведений(знач ТекстXML) Экспорт
	
	ЧтениеXML = Новый ЧтениеXML;
	ЧтениеXML.УстановитьСтроку(ТекстXML);
	
	ЧтениеXML.Прочитать();
	
	Результат = Новый Соответствие;
	
	Пока ЧтениеXML.Прочитать() Цикл
		КодАдресногоОбъекта = ПолучитьАтрибут(ЧтениеXML, "code");
		Если ЗначениеЗаполнено(КодАдресногоОбъекта) Тогда
			ДатаВыпуска         = ПолучитьАтрибут(ЧтениеXML, "date");
			Результат.Вставить(КодАдресногоОбъекта, ДатаВыпуска);
		КонецЕсли;
		ЧтениеXML.Прочитать();
	КонецЦикла;
	
	ЧтениеXML.Закрыть();
	
	Возврат Результат;
	
КонецФункции

// Читает значение атрибута по имени из указанного объекта, приводит значение
// к указанному примитивному типу
//
// Параметры:
//  ЧтениеXML      - объект типа ЧтениеXML, спозиционированный на начале элемента,
//                атрибут которого требуется получить
//  Тип         - Значение типа Тип. Тип атрибута
//  Имя         - Строка. Имя атрибута
//
// Возвращаемое значение:
// Значение атрибута полученное по имени и приведенное к указанному типу
//
Функция ПолучитьАтрибут(знач ЧтениеXML, Знач Имя)
	
	СтрЗначение = СокрЛП(ЧтениеXML.ПолучитьАтрибут(Имя));
	
	Если		Имя = "date" Тогда
		Возврат Дата(Сред(СтрЗначение, 7, 4) + Сред(СтрЗначение, 4, 2) + Лев(СтрЗначение, 2));
	ИначеЕсли	Имя = "code" Тогда
		Возврат Лев(СтрЗначение, 2);
	КонецЕсли;
	
КонецФункции

// Функция ставит на поддержку адресные объекты. Фактически происходит заполнение
// регистра сведений соответствием кодов адресных объектов датами актуальности
// Параметры
// ТекстXML        - многострочная строка - текст файла с описанием версий адресных объектов
// АдресныеОбъекты - массив - список адресных объектов, каждая строка - код
//                   адресного объекта в формате NN
//
Процедура ОбновитьВерсиюАдресныхСведений(ТекстXML, АдресныеОбъекты) Экспорт
	
	ВерсииАдресныхСведений = ПолучитьВерсииАдресныхСведений(ТекстXML);
	
	Для Каждого АдресныйОбъект Из АдресныеОбъекты Цикл
		АдресныеСведения = ИнформацияПоАдресномуОбъекту(АдресныйОбъект);
		УстановитьВерсиюКлассификатора(АдресныйОбъект,
		                               АдресныеСведения.Наименование + " " + АдресныеСведения.Сокращение,
		                               ВерсииАдресныхСведений[АдресныйОбъект]);
	КонецЦикла;
	
КонецПроцедуры

// Сохраняет файл архива из двоичных данных на сервере по 
// переданному имени в переданном каталоге, и распаковывает его.
//
// Параметры
// ДвоичныеДанные - ДвоичныеДанные -данные файла
// ИмяФайлаАрхива - строка - имя файла
// ПутьККаталогуНаСервере - путь к каталогу, в который требуется положить распакованный файл
//
Процедура СохранитьФайлНаСервереИРаспаковать(знач ДвоичныеДанные,
                                             ИмяФайлаАрхива,
                                             ПутьККаталогуНаСервере) Экспорт
	
	Если ПутьККаталогуНаСервере = Неопределено Тогда
		ПутьККаталогуНаСервере = ОбщегоНазначенияКлиентСервер.ПолучитьИмяКаталога("kladr_files");
	КонецЕсли;
	
	ДвоичныеДанные.Записать(ПутьККаталогуНаСервере + ИмяФайлаАрхива);
	
	ЧтениеZIP = Новый ЧтениеZipФайла(ПутьККаталогуНаСервере + ИмяФайлаАрхива);
	ЧтениеZIP.ИзвлечьВсе(ПутьККаталогуНаСервере,
	                     РежимВосстановленияПутейФайловZIP.НеВосстанавливать);
	ЧтениеZIP.Закрыть();
	УдалитьФайлы(ПутьККаталогуНаСервере, ИмяФайлаАрхива);
	
КонецПроцедуры

// ---------------------------------------------------------------
// Аутентификация на пользовательском сайте 1С

// Получает параметры аутентификации пользователя (логин и пароль) на пользовательском сайте 1с.
// Возвращаемое значение:
// Булево - Истина - параметры аутентификации заполнены
//          Ложь   - хотя бы один из параметров аутентификации не заполнен
//
Функция ПолучитьПараметрыАутентификации(КодПользователя, Пароль) Экспорт
	
	Значение = ХранилищеОбщихНастроек.Загрузить("АутентификацияНаПользовательскомСайте", "КодПользователя");
	
	КодПользователя = ? (Значение = Неопределено, "", Значение);
	
	Значение = ХранилищеОбщихНастроек.Загрузить(
	                  "АутентификацияНаПользовательскомСайте",
	                  "Пароль");
	
	Пароль = ? (Значение = Неопределено, "", Значение);
	
	Возврат ((? (КодПользователя = Неопределено, Ложь, Истина))
	       И (? (ПустаяСтрока(Пароль), Ложь, Истина)))
	
КонецФункции

// Сохраняет код пользователя и пароль в системном хранилище настроек ИБ
// Параметры
// КодПользователя - строка - код пользователя, или логин, для доступа к пользовательскому сайту 1с
// Пароль - строка - пароль
//
Процедура СохранитьПараметрыАутентификации(КодПользователя, Пароль) Экспорт
	
	ХранилищеОбщихНастроек.Сохранить(
	             "АутентификацияНаПользовательскомСайте",
	             "КодПользователя",
	             КодПользователя,,
	             Пользователи.АвторизованныйПользователь());
	
	ХранилищеОбщихНастроек.Сохранить(
	             "АутентификацияНаПользовательскомСайте",
	             "Пароль",
	             Пароль,,
	             Пользователи.АвторизованныйПользователь());
	
КонецПроцедуры
