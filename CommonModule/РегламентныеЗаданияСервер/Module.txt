
////////////////////////////////////////////////////////////////////////////////
// ПРОЦЕДУРЫ ОБЩЕГО НАЗНАЧЕНИЯ

// Процедура ВызватьИсключениеЕслиНетПраваАдминистрирования вызывает исключение,
// если у пользователя нет права администрирования.
//
Процедура ВызватьИсключениеЕслиНетПраваАдминистрирования()

	ВыполняетсяПроцедураОбработатьРегламентныеЗадания = ХранилищеОбщихНастроек.Загрузить("ВыполняетсяПроцедураОбработатьРегламентныеЗадания");
	Если ТипЗнч(ВыполняетсяПроцедураОбработатьРегламентныеЗадания) <> Тип("Булево") Тогда
		ВыполняетсяПроцедураОбработатьРегламентныеЗадания = Ложь;
	КонецЕсли;
	
	Если НЕ ВыполняетсяПроцедураОбработатьРегламентныеЗадания И
	     НЕ ПравоДоступа("Администрирование", Метаданные) Тогда
		
		ВызватьИсключение(НСтр("ru = 'У пользователя нет права администрирования!'"));
	КонецЕсли;
	
КонецПроцедуры // ВызватьИсключениеЕслиНетПраваАдминистрирования()

// Процедура ДобавитьВСписокЗначенийИменаПользователей добавляет
// в Список имена пользователей, как они заданы в конфигураторе.
//
// Параметры:
//  Список       - СписокЗначений - обычно СписокВыбора ПоляВвода.
//
Процедура ДобавитьВСписокЗначенийИменаПользователей(Список) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	// Заполним список имен пользователей информационной базы для выбора
	МассивПользователей = ПользователиИнформационнойБазы.ПолучитьПользователей();
	Для каждого Пользователь Из МассивПользователей Цикл
		Список.Добавить(Пользователь.Имя);
	КонецЦикла;

КонецПроцедуры // ДобавитьВСписокЗначенийИменаПользователей()

// Функция ТекущийСеансОбрабатываетЗадания определяет, что текущий сеанс обрабатывает задания,
// если это не так и указано установить текущий сеанс в этом качестве, то производится попытка
// установки.
//
// Параметры:
//  ЗаданияОбрабатываютсяНормально - Булево - Истина, если нет отклонений в выполнении заданий.
//  УстановитьТекущийСеансКакСеансОбрабатывающийЗадания - Булево - Истина, если требуется установить
//               текущий сеанс, как сеанс в котором будет происходить обработка, если не удалось установить,
//               тогда функция вернет Ложь.
//  ОписаниеОшибки - Строка - Если НЕ ЗаданияОбрабатываютсяНормально, тогда описание отклонения:
//               либо обработка долго не стартует, либо долго выполняется.
//
// Возвращаемое значение:
//  Булево.
//
Функция ТекущийСеансОбрабатываетЗадания(ЗаданияОбрабатываютсяНормально = Неопределено,
                                        Знач УстановитьТекущийСеансКакСеансОбрабатывающийЗадания = Ложь,
                                        ОписаниеОшибки = "") Экспорт
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		ЗаданияОбрабатываютсяНормально = Истина;
		ОписаниеОшибки = НСтр("ru = 'Задания обрабатываются на сервере!'");
		Возврат Ложь;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	НачатьТранзакцию();
	Попытка
		Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий(Истина);
		Сеансы = ПолучитьСеансыИнформационнойБазы();
		НайденСеансОбрабатывающийЗадания = Ложь;
		ТекущийСеансОбрабатываетЗадания  = Ложь;
		ЗаданияОбрабатываютсяНормально   = Истина;
		
		// Найдем сеанс обработки заданий, установленный в константе СостояниеОбработкиРегламентныхЗаданий,
		// среди активных сеансов, и текущий сеанс (начало текущего сеанса может понадобится
		// для инициализации Структуры).
		Для каждого Сеанс Из Сеансы Цикл
			Если Сеанс.НомерСеанса = НомерСеансаИнформационнойБазы() Тогда
				ТекущийСеанс = Сеанс;
			КонецЕсли;
			Если Сеанс.НомерСеанса 	= Состояние.НомерСеанса
			   И Сеанс.НачалоСеанса = Состояние.НачалоСеанса Тогда
			   	НайденныйСеанс 		= Сеанс;
				НайденСеансОбрабатывающийЗадания = Истина;
				ТекущийСеансОбрабатываетЗадания  = (Сеанс.НомерСеанса = НомерСеансаИнформационнойБазы());
			КонецЕсли;
		КонецЦикла;
		Если НЕ НайденСеансОбрабатывающийЗадания И УстановитьТекущийСеансКакСеансОбрабатывающийЗадания Тогда
			МоментТекущегоВремени                           = ТекущаяДата();
			Состояние.НомерСеанса                           = ТекущийСеанс.НомерСеанса;
			Состояние.НачалоСеанса                          = ТекущийСеанс.НачалоСеанса;
			Состояние.ИмяКомпьютера                         = ИмяКомпьютера();
			Состояние.ИмяПриложения                         = ТекущийСеанс.ИмяПриложения;
			Состояние.ИмяПользователя                       = ИмяПользователя();
			Состояние.ИдентификаторОчередногоЗадания        = Неопределено;
			Состояние.НачалоОбработкиОчередногоЗадания      = МоментТекущегоВремени;
			Состояние.ОкончаниеОбработкиОчередногоЗадания   = МоментТекущегоВремени;
			ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
			НайденСеансОбрабатывающийЗадания = Истина;
			ТекущийСеансОбрабатываетЗадания  = Истина;
			ЗафиксироватьТранзакцию();
		Иначе
			ОтменитьТранзакцию();
		КонецЕсли;
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	Если НЕ НайденСеансОбрабатывающийЗадания Тогда
		ОписаниеОшибки = НСтр("ru = 'Нет сеанса, обрабатывающего регламентные задания!'");
		ЗаданияОбрабатываютсяНормально = Ложь;
	ИначеЕсли Состояние.Настройки.БлокировкаОбработкиРегламентныхЗаданий Тогда
		ОписаниеОшибки = НСтр("ru = 'Выполнение регламентных заданий заблокировано!'");
		ЗаданияОбрабатываютсяНормально = Ложь;
	ИначеЕсли НЕ ЗначениеЗаполнено(Состояние.ОкончаниеОбработкиОчередногоЗадания) Тогда
		// Если после завершения очередного задания прошло более часа, значит задержка запуска.
		Если ТекущаяДата() - 360 > Состояние.ОкончаниеОбработкиОчередногоЗадания Тогда
			ОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Запуск обработки регламентных заданий задерживается более 1 часа!
					           |Возможно требуется проверка и перезапуск сеанса. Запуск ожидается
					           |    на компьютере:         %1,
					           |    в приложении:          %2,
					           |    от имени пользователя: %3,
					           |    в сеансе номер:        %4.'"),
					Строка(Состояние.ИмяКомпьютера),
					Строка(Состояние.ИмяПриложения),
					Строка(Состояние.ИмяПользователя),
					Строка(Состояние.НомерСеанса) );
			ЗаданияОбрабатываютсяНормально = Ложь;
		КонецЕсли;
	
	Иначе
		// Если обработка продолжается более 1 часа, значить она слишком затянулась.
		Если ТекущаяДата() - 360 > Состояние.НачалоОбработкиОчередногоЗадания Тогда
			ОписаниеОшибки = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
					НСтр("ru = 'Обработка регламентного задания выполняется непрерывно уже более 1 часа!
					           |Возможно требуется проверка и перезапуск сеанса. Выполнение происходит
					           |    на компьютере:         %1,
					           |    в приложении:          %2,
					           |    от имени пользователя: %3,
					           |    в сеансе номер:        %4.'"),
					Строка(Состояние.ИмяКомпьютера),
					Строка(Состояние.ИмяПриложения),
					Строка(Состояние.ИмяПользователя),
					Строка(Состояние.НомерСеанса));
			ЗаданияОбрабатываютсяНормально = Ложь;
		КонецЕсли;
	КонецЕсли;
	Возврат ТекущийСеансОбрабатываетЗадания;
	
КонецФункции // ТекущийСеансОбрабатываетЗадания()

// Функция РодительскийСеансЗаданИЗавершен проверяет,
// что сеанс открывший этот дополнительный сеанс для обработки
// регламентных заданий завершен, если задан.
//
// Параметры:
//  ПараметрЗапуска - Строка - значение глобального свойства ПараметрЗапуска,
//                 требуется указывать, т.к. свойство недоступно на сервере.
//  РодительскийСеансЗадан - Булево - возвращает Истина, если родительский сеанс задан,
//                 иначе возвращает Ложь.
//
// Возвращаемое значение:
//  Булево.
//
Функция РодительскийСеансЗаданИЗавершен(Знач ПараметрЗапуска) Экспорт

	РодительскийСеансЗадан = Ложь;
	Если Найти(ПараметрЗапуска, "DoScheduledJobs") <> 0 Тогда
		ИндексНомераСеанса = Найти(ПараметрЗапуска, "SessionNumber=");
		ИндексНачалаСеанса = Найти(ПараметрЗапуска, "SessionStarted=");
		Если ИндексНомераСеанса <> 0 И
		     ИндексНачалаСеанса <> 0 И
		     ИндексНомераСеанса < ИндексНачалаСеанса Тогда
			РодительскийСеансЗадан = Истина;
		    Сеансы = ПолучитьСеансыИнформационнойБазы();
			Для каждого Сеанс Из Сеансы Цикл
				Если Найти(ПараметрЗапуска, "SessionNumber="  + Сеанс.НомерСеанса)  <> 0 И
				     Найти(ПараметрЗапуска, "SessionStarted=" + Сеанс.НачалоСеанса) <> 0 Тогда
					Возврат Ложь;
				КонецЕсли;
			КонецЦикла;
			Возврат Истина;
		КонецЕсли;
	КонецЕсли;
	Возврат Ложь;

КонецФункции // РодительскийСеансЗаданИЗавершен()

////////////////////////////////////////////////////////////////////////////////
// ЭКСПРОТНЫЕ МЕТОДЫ РАСШИРЕНИЯ МЕНЕДЖЕРА РЕГЛАМЕНТНЫХ ЗАДАНИЙ
//

// Процедура ОбработатьРегламентныеЗадания() эмулирует в тонком клиенте
// системную процедуру ВыполнитьОбработкуЗаданий(), но может применяться и
// в толстом клиенте.
//
//  Место хранения экземпляров фоновых заданий - ВременноеХранилище.
// Время хранения экземпляров - до закрытия сеанса клиента, выполняющего обработку.
// Максимальное количество одновременно хранимых фоновых заданий: 1000.
//
//  Идентификатор сеанса, выполняющего обработку находится в константе
// СостояниеОбработкиРегламентныхЗаданий (ХранилищеЗначения), содержащее структуру
// со свойствами: 
// НомерСеанса, НачалоСеанса, ИдентификаторОчередногоЗадания,
// НачалоОбработкиОчередногоЗадания, ОкончаниеОбработкиОчередногоЗадания и др.
//  Логика проверки на выполнение обработки заданий именно в текущем сеансе:
// Если <НомерСеанса> и  <НачалоСеанса> совпадают с текущим,
// Тогда выполняем, если нет, тогда проверяем существует ли сеанс в списке сеансов,
// если не существует, тогда выполняем, если существует тогда не выполняем, но
// проверяем период выполнения/простоя. Если "выполняется"/"простаивает" дольше
// 1 час будем уведомлять пользователя (ошибка с соответствующим описанием).
//  Логика порядка выполнения заданий. Задания выполняются последовательно,
// регистрируется последнее запущенное задание. При новой проверке, проверяемым
// заданием будет задание, следующее за запущенным. 
//  Логика проверки расписания. Если произошла ошибка тогда используется аварийное
// расписание, иначе - основное.
// 
// Параметры:
//  ВремяОбработки - Число(10.0) - Время в секундах обработки очередной
//                 порции заданий. Если время не задано, будет выполнен
//                 только один цикл обработки (до завершения одного фонового
//                 задания или обработки всех регламентных заданий).
//
// Возвращаемое значение:
//  Булево       - НЕ Отказ.
//
Процедура ОбработатьРегламентныеЗадания(ВремяОбработки = 0, УведомлятьПользователя = Ложь) Экспорт
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Возврат;
	КонецЕсли;
	
	УстановитьПривилегированныйРежим(Истина);
	
	Если НЕ ТекущийСеансОбрабатываетЗадания() Тогда
		Возврат;
	КонецЕсли;
	
	Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
	Если Состояние.Настройки.БлокировкаОбработкиРегламентныхЗаданий Тогда
		Возврат;
	КонецЕсли;

	// Разрешаем вызов привилегированных функций на время выполнения этой процедуры.
	ХранилищеОбщихНастроек.Сохранить("ВыполняетсяПроцедураОбработатьРегламентныеЗадания", , Истина);
	
	ВремяОбработки = ?(ТипЗнч(ВремяОбработки) = Тип("Число"), ВремяОбработки, 0);

	Задания                        = РегламентныеЗадания.ПолучитьРегламентныеЗадания();
	ОбработкаЗавершена             = Ложь; // Определяет, что ВремяОбработки закончилось, или
	                                       // все возможные задания обработаны.
	НачалоОбработки                = ТекущаяДата();
	КоличествоОбработанныхЗаданий  = 0;
	ФоновоеЗаданиеВыполнялось      = Ложь;
	ИдентификаторПоследнегоЗадания = Состояние.ИдентификаторОчередногоЗадания;

	// Количество заданий будем проверять каждый раз при запуске обработки,
	// т.к. они могут быть удалены в другом сеансе, а тогда будет зацикливание.
	Пока НЕ ОбработкаЗавершена И Задания.Количество() > 0 Цикл
		ПервоеЗаданиеНайдено           = (ИдентификаторПоследнегоЗадания = Неопределено);
		ОчередноеЗаданиеНайдено        = Ложь;
		Для каждого Задание ИЗ Задания Цикл
			// Завершаем обработку, если:
			// а) время задано и вышло;
			// б) время не задано и хоть одно фоновое задание выполнено;
			// в) время не задано и все регламентные задания обработаны по количеству.
			Если ( ВремяОбработки = 0 И
			       ( ФоновоеЗаданиеВыполнялось ИЛИ
			         КоличествоОбработанныхЗаданий >= Задания.Количество() ) ) ИЛИ
			     ( ВремяОбработки <> 0 И
			       НачалоОбработки + ВремяОбработки <= ТекущаяДата() ) Тогда
				ОбработкаЗавершена = Истина;
				Прервать;
			КонецЕсли;
			Если НЕ ПервоеЗаданиеНайдено Тогда
				Если Строка(Задание.УникальныйИдентификатор) = ИдентификаторПоследнегоЗадания Тогда
				   // Найдено последнее обработанное задание, значит следующее
				   // задание нужно проверять на необходимость обработки.
				   ПервоеЗаданиеНайдено = Истина;
				КонецЕсли;
				// Если первое задание, которое нужно проверить на необходимость
				// запуска ещё не найдено, тогда пропускаем текущее задание.
				Продолжить;
			КонецЕсли;
			ОчередноеЗаданиеНайдено = Истина;
			КоличествоОбработанныхЗаданий = КоличествоОбработанныхЗаданий + 1;
			Состояние.ИдентификаторОчередногоЗадания      = Строка(Задание.УникальныйИдентификатор);
			Состояние.НачалоОбработкиОчередногоЗадания    = ТекущаяДата();
			Состояние.ОкончаниеОбработкиОчередногоЗадания = '00010101';
			ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние,
			                                              "ИдентификаторОчередногоЗадания,
			                                              |НачалоОбработкиОчередногоЗадания,
			                                              |ОкончаниеОбработкиОчередногоЗадания");
			Если Задание.Использование Тогда
				ОбработатьРегламентноеЗадание = Ложь;
				СвойстваПоследнегоФоновогоЗадания = ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания(Задание);
				
				Если СвойстваПоследнегоФоновогоЗадания <> Неопределено И
				     СвойстваПоследнегоФоновогоЗадания.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно Тогда
					// Проверка аварийного расписания.
					Если СвойстваПоследнегоФоновогоЗадания.ПопыткаЗапуска <= Задание.КоличествоПовторовПриАварийномЗавершении Тогда
						Если СвойстваПоследнегоФоновогоЗадания.Конец + Задание.ИнтервалПовтораПриАварийномЗавершении <= ТекущаяДата() Тогда
						    // Повторный запуск фонового задания по регламентному заданию.
						    ОбработатьРегламентноеЗадание = Истина;
						КонецЕсли;
					КонецЕсли;
				Иначе
					// Проверяем стандартное расписание.
					ОбработатьРегламентноеЗадание = Задание.Расписание.ТребуетсяВыполнение(
						ТекущаяДата(),
						?(СвойстваПоследнегоФоновогоЗадания = Неопределено, '00010101', СвойстваПоследнегоФоновогоЗадания.Начало),
						?(СвойстваПоследнегоФоновогоЗадания = Неопределено, '00010101', СвойстваПоследнегоФоновогоЗадания.Конец ));
				КонецЕсли;
				Если ОбработатьРегламентноеЗадание Тогда
					ОбработатьРегламентноеЗадание(Задание);
					ФоновоеЗаданиеВыполнялось = Истина;
				КонецЕсли;
			КонецЕсли;
			Состояние.ОкончаниеОбработкиОчередногоЗадания = ТекущаяДата();
			ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние, "ОкончаниеОбработкиОчередногоЗадания");
		КонецЦикла;
		// Если последнее выполненное задание найти не удалось, тогда
		// сбросим его Идентификатор, чтобы начать проверку регламентных заданий с первого.
		ИдентификаторПоследнегоЗадания = Неопределено;
	КонецЦикла;
	
	// Запрещаем вызов привилегированных функций после выполнения этой процедуры.
	ХранилищеОбщихНастроек.Сохранить("ВыполняетсяПроцедураОбработатьРегламентныеЗадания", , Ложь);
	
КонецПроцедуры // ОбработатьРегламентныеЗадания()

// Процедура УстановитьНастройкиОбработкиРегламентныхЗаданий устанавливает
// настройки для файлового режима обработки заданий.
// 
// Параметры:
//  Настройки - Структура.
//
Процедура УстановитьНастройкиОбработкиРегламентныхЗаданий(Настройки) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Настройки = ОбновитьНастройки(Настройки);
	
	НачатьТранзакцию();
	Попытка
		Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий(Истина);
		Если Состояние.Настройки.БлокировкаОбработкиРегламентныхЗаданий <> Настройки.БлокировкаОбработкиРегламентныхЗаданий Тогда
			ВызватьИсключениеЕслиНетПраваАдминистрирования();
		КонецЕсли;
		Состояние.Настройки = Настройки;
		ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры // УстановитьНастройкиОбработкиРегламентныхЗаданий()

// Процедура ПолучитьНастройкиОбработкиРегламентныхЗаданий получает настройки
// для файлового режима обработки заданий.
// 
// Возвращаемое значение:
//  Настройки - Структура.
//
Функция ПолучитьНастройкиОбработкиРегламентныхЗаданий() Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Возврат ПолучитьСостояниеОбработкиРегламентныхЗаданий().Настройки;
	
КонецФункции // ПолучитьНастройкиОбработкиРегламентныхЗаданий()

// Функция возвращает представление регламентного задания,
// это по порядку исключения незаполненных реквизитов:
// Наименование, Метаданные.Синоним, Метаданные.Имя.
//
// Параметры:
//  Задание      - РегламентноеЗадание, Строка - если строка, тогда УникальныйИдентификатор строкой.
//
// Возвращаемое значение:
//  Строка.
//
Функция ПредставлениеРегламентногоЗадания(Знач Задание) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	Если ТипЗнч(Задание) = Тип("РегламентноеЗадание") Тогда
		РегламентноеЗадание = Задание;
	Иначе
		РегламентноеЗадание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(Новый УникальныйИдентификатор(Задание));
	КонецЕсли;
	
	Если РегламентноеЗадание <> Неопределено Тогда
		Представление = РегламентноеЗадание.Наименование;
		Если ПустаяСтрока(РегламентноеЗадание.Наименование) Тогда
			// Применим синоним вместо наименования
			Представление = РегламентноеЗадание.Метаданные.Синоним;
			Если ПустаяСтрока(Представление) Тогда
				// Применим имя вместо синонима
				Представление = РегламентноеЗадание.Метаданные.Имя;
			КонецЕсли
		КонецЕсли;
	Иначе
		Представление = ТекстНеОпределено();
	КонецЕсли;
	
	Возврат Представление;
	
КонецФункции // ПредставлениеРегламентногоЗадания()

// Служебная функция, возвращающая текст "<не определено>" с локализацией.
// Используется для целей локализации
//
Функция ТекстНеОпределено() Экспорт
	
	Возврат НСтр("ru = '<не определено>'");
	
КонецФункции

// Функция ПолучитьРегламентноеЗадание получает РегламентноеЗадание из информационной
// базы по строке уникального идентификатора.
//
// Параметры:
//  Идентификатор - Строка уникального идентификатора РегламентногоЗадания.
// 
// Возвращаемое значение:
//  РегламентноеЗадание.
//
Функция ПолучитьРегламентноеЗадание(Знач Идентификатор) Экспорт

	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	РегламентноеЗадание = РегламентныеЗадания.НайтиПоУникальномуИдентификатору(Новый УникальныйИдентификатор(Идентификатор));
	
	Если РегламентноеЗадание = Неопределено Тогда
		ВызватьИсключение( НСтр("ru = 'Задание не найдено в списке!
		                              |Возможно, оно удалено другим пользователем!'") );
	КонецЕсли;
	
	Возврат РегламентноеЗадание;
	
КонецФункции // ПолучитьРегламентноеЗадание()

// Процедура ОбработатьРегламентноеЗаданиеВручную предназначена для
// "ручного" немедленного выполнения процедуры регламентного задания
// либо в сеансе клиента (в файловой ИБ), либо в фоновом задании на сервере (в серверной ИБ).
// Применяется в любом режиме соединения.
// "Ручной" режим запуска не влияет на выполнение регламентного задания по аварийному
// и основному расписаниям, т.к. не указывается ссылка на регламентное задание у фонового задания.
// Тип ФоновоеЗадание не допускает установки такой ссылки, поэтому для файлового режима применяется
// тоже правило.
// 
// Параметры:
//  Задание       - РегламентноеЗадание, Строка уникального идентификатора РегламентногоЗадания.
//  МоментЗапуска - Неопределено, Дата(дата и время). Для файловой ИБ устанавливает переданный
//                 момент, как момент запуска. Для серверной ИБ - возвращает момент запуска 
//                 фонового задания по факту.
//  ИдентификаторФоновогоЗадания - Строка - идентификатор запущенного фонового задания.
//
//
Процедура ОбработатьРегламентноеЗаданиеВручную(Знач Задание,
                                               МоментЗапуска = Неопределено,
                                               ИдентификаторФоновогоЗадания = "") Экспорт

	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	Задание = ?(ТипЗнч(Задание) = Тип("РегламентноеЗадание"), Задание, ПолучитьРегламентноеЗадание(Задание));
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		ОбработатьРегламентноеЗадание(Задание, Истина, МоментЗапуска, ИдентификаторФоновогоЗадания);
		// Обновление состояния уже выполнено в вызванной процедуре.
	Иначе
		НачатьТранзакцию();
		Попытка
			Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий(Истина);
			НаименованиеФоновогоЗадания = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Запуск вручную: %1'"), ПредставлениеРегламентногоЗадания(Задание));
			ФоновоеЗадание = ФоновыеЗадания.Выполнить(Задание.Метаданные.ИмяМетода, Задание.Параметры, Задание.Ключ, НаименованиеФоновогоЗадания);
			ИдентификаторФоновогоЗадания = Строка(ФоновоеЗадание.УникальныйИдентификатор);
			Состояние.Соответствие_ИФЗ_ИРЗ_ЗапущенныеНаСервереВручную.Вставить( ИдентификаторФоновогоЗадания, Строка(Задание.УникальныйИдентификатор) );
			МоментЗапуска = ФоновыеЗадания.НайтиПоУникальномуИдентификатору(ФоновоеЗадание.УникальныйИдентификатор).Начало;
			ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
	КонецЕсли;
	
КонецПроцедуры // ОбработатьРегламентноеЗаданиеВручную()

// Функция НужноУведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий возвращает
// значение флажка настройки обработки регламентных заданий.
//
// Возвращаемое значение:
//  Булево.
//
Функция НужноУведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий(ПериодУведомления) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	УведомлятьОНекорректномСостоянии = Ложь;
	
	Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
		ПериодУведомления = Состояние.Настройки.ПериодУведомленияОСостоянииОбработкиРегламентныхЗаданий;
		ПериодУведомления = ?(ПериодУведомления <= 0, 1, ПериодУведомления);
		УведомлятьОНекорректномСостоянии = Состояние.Настройки.УведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий;
	Иначе
		ПериодУведомления = 1;
	КонецЕсли;
	
	Возврат УведомлятьОНекорректномСостоянии;
	
КонецФункции // НужноУведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий()

// Функция СообщенияИОписанияОшибокРегламентногоЗадания возвращает
// многострочную Строку содержащую Сообщения и ОписаниеИнформацииОбОшибке,
// последнее фоновое задание найдено по идентификатору регламентного задания
// и сообщения/ошибки есть.
//
// Параметры:
//  Задание      - РегламентноеЗадание, Строка - УникальныйИдентификатор
//                 РегламентногоЗадания строкой.
//
// Возвращаемое значение:
//  Строка.
//
Функция СообщенияИОписанияОшибокРегламентногоЗадания(Знач Задание) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();

	ИдентификаторРегламентногоЗадания = ?(ТипЗнч(Задание) = Тип("РегламентноеЗадание"), Строка(Задание.УникальныйИдентификатор), Задание);
	СвойстваПоследнегоФоновогоЗадания = ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания(ИдентификаторРегламентногоЗадания);
	Возврат ?(СвойстваПоследнегоФоновогоЗадания = Неопределено,
	          "",
	          СообщенияИОписанияОшибокФоновогоЗадания(СвойстваПоследнегоФоновогоЗадания.Идентификатор) );
	
КонецФункции // СообщенияИОписанияОшибокРегламентногоЗадания()

// Возвращает параметры открытия сеанса обработки регламентных заданий.
//
// Параметры:
//  ПоНастройкеАвтоОткрытия - Булево - открывать сеанс, если настроено выполнять
//                 автоматическое открытие и не серверная ИБ и не Веб-клиент и
//                 сеанс уже не открыт. В других случаях устанавливается Отказ.
//
// Возвращаемое значение:
//  Структура -    ТребуетсяОткрытьОтдельныйСеанс             - Булево - Истина.
//                 ДополнительныеПараметрыКоманднойСтроки     - Строка - дополнительные параметры командной строки для
//                                                              открытия сеанса обработки регламентных заданий.
//                 ВыполненаПопыткаОткрытия                   - Булево - Ложь, для использования в вызывающей процедуре.
//                 УведомлятьОНекорректномСостоянииОбработки  - Булево.
//                 ПериодУведомления                          - Число.
//                 Отказ                                      - Булево.
//                 ОписаниеОшибки                             - Строка.
//
Функция ПараметрыОткрытияСеансаОбработкиРегламентныхЗаданий(Знач ПоНастройкеАвтоОткрытия = Ложь) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Результат = Новый Структура;
	Результат.Вставить("ТребуетсяОткрытьОтдельныйСеанс", Ложь);
	Результат.Вставить("ВыполненаПопыткаОткрытия", Ложь);
	Результат.Вставить("ДополнительныеПараметрыКоманднойСтроки", "");
	Результат.Вставить("УведомлятьОНекорректномСостоянииОбработки", Ложь);
	Результат.Вставить("ПериодУведомления", Неопределено);
	Результат.Вставить("Отказ", Ложь);
	Результат.Вставить("ОписаниеОшибки", "");
	
	Если ПоНастройкеАвтоОткрытия Тогда
		Результат.Вставить("ТекущийПользовательАдминистратор", ПравоДоступа("Администрирование", Метаданные, ПользователиИнформационнойБазы.ТекущийПользователь()));
	КонецЕсли;
	
	Результат.УведомлятьОНекорректномСостоянииОбработки = НужноУведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий(Результат.ПериодУведомления);
	
	Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий();
	
	Если ПоНастройкеАвтоОткрытия И НЕ Состояние.Настройки.АвтоматическиОткрыватьОтдельныйСеансОбработкиРегламентныхЗаданий Тогда
		Возврат Результат;
	КонецЕсли;
	
	Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		Если ПоНастройкеАвтоОткрытия Тогда
			Возврат Результат;
		Иначе
			Результат.Отказ = Истина;
			Результат.ОписаниеОшибки = НСтр("ru = 'Регламентные задания обрабатываются на сервере!'");
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;

	ЗаданияОбрабатываютсяНормально = Неопределено;
	ТекущийСеансОбрабатываетЗадания(ЗаданияОбрабатываютсяНормально);
	Если ЗаданияОбрабатываютсяНормально Тогда
		Если ПоНастройкеАвтоОткрытия Тогда
			Возврат Результат;
		Иначе
			Результат.Отказ = Истина;
			Результат.ОписаниеОшибки = НСтр("ru = 'Сеанс, выполняющий регламентные задания, уже открыт!'");
			Возврат Результат;
		КонецЕсли;
	КонецЕсли;
	
	НомерТекущегоСеанса = НомерСеансаИнформационнойБазы();
	// Определим начало текущего сеанса.
	НачалоТекущегоСеанса = '00010101';
	Сеансы = ПолучитьСеансыИнформационнойБазы();
	Для каждого Сеанс Из Сеансы Цикл
		Если Сеанс.НомерСеанса = НомерТекущегоСеанса Тогда
			НачалоТекущегоСеанса = Сеанс.НачалоСеанса;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	Результат.ДополнительныеПараметрыКоманднойСтроки = """"
		+ " /C""DoScheduledJobs SkipMessageBox AloneIBSession "
		+ "SessionNumber=" + НомерТекущегоСеанса + " SessionStarted=" + НачалоТекущегоСеанса + """";
	
	Результат.ТребуетсяОткрытьОтдельныйСеанс = Истина;
	
	Возврат Результат;
	
КонецФункции // ПараметрыОткрытияСеансаОбработкиРегламентныхЗаданий()

Функция ПолучитьРасписаниеРегламентногоЗадания(Знач Идентификатор) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	Возврат ПолучитьРегламентноеЗадание(Идентификатор).Расписание;
	
КонецФункции

Процедура УстановитьРасписаниеРегламентногоЗадания(Знач Идентификатор, Знач Расписание) Экспорт
	
	УстановитьПривилегированныйРежим(Истина);
	
	Задание = ПолучитьРегламентноеЗадание(Идентификатор);
	Задание.Расписание = Расписание;
	Задание.Записать();
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// ЭКСПОРТНЫЕ МЕТОДЫ ОБОБЩЕННОГО МЕНЕДЖЕРА ФОНОВЫХ ЗАДАНИЙ
//
// Обобщенный менеджер фоновых заданий работает как файловом, так и серверном режиме
// эксплуатации информационной базы.

// Функция ПолучитьТаблицуСвойствФоновыхЗаданий() "эмулирует" функцию
// ФоновыеЗадания.ПолучитьФоновыеЗадания() для любого режима соединения.
//  Структуру таблицы  смотри в функции ПроверитьТаблицуФоновыхЗаданий().
// 
// Параметры:
//  Отбор        - Структура - допустимые поля:
//                 УникальныйИдентификатор, Ключ, Состояние, Начало, Конец,
//                 Наименование, ИмяМетода, РегламентноеЗадание. 
//  ВсегоЗаданий - Число - возвращает общее количество заданий без учета отбора.
//  ПрочитанноеСостояние - Неопределено, только для внутреннего использования.
//
// Возвращаемое значение:
//  ТаблицаЗначений  - возвращается таблица после отбора.
//
Функция ПолучитьТаблицуСвойствФоновыхЗаданий(Отбор = Неопределено, ВсегоЗаданий = 0, Знач ПрочитанноеСостояние = Неопределено) Экспорт

	ВызватьИсключениеЕслиНетПраваАдминистрирования();

	Если ПрочитанноеСостояние = Неопределено Тогда
		НачатьТранзакцию();
	КонецЕсли;
	Попытка
		Если ПрочитанноеСостояние = Неопределено Тогда
			Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий(Истина);
		Иначе
			Состояние = ПрочитанноеСостояние;
		КонецЕсли;
		ТаблицаОбновлена = НЕ ПроверитьТаблицуФоновыхЗаданий(Состояние.ТаблицаФоновыхЗаданий);
		Таблица = Состояние.ТаблицаФоновыхЗаданий;
		Если НЕ ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
			// Дополним таблицу фоновых заданий.
			// 1. Определим момент с которого нужно дополнять.
			//    Для этого найдем первое активное задание, выполняемое на сервере.
			//    Если такового нет, тогда последнее задание выполняемое на сервере.
			//    Дата начала его выполнения и будет началом периода.
			СтрокиАктивных = Таблица.НайтиСтроки(Новый Структура("НаСервере, Состояние", Истина, СостояниеФоновогоЗадания.Активно));
			Начало = Неопределено;
			Если СтрокиАктивных.Количество() <> 0 Тогда
				// Выберем минимальную дату начала.
				Начало = СтрокиАктивных[0].Начало;
				Для каждого Строка Из СтрокиАктивных Цикл
					Начало = ?(Строка.Начало < Начало, Строка.Начало, Начало);
				КонецЦикла;
			Иначе
				ПоследняяСтрока = Таблица.Найти(Истина, "НаСервере");
				Если ПоследняяСтрока <> Неопределено Тогда
					Начало = ПоследняяСтрока.Начало;
				КонецЕсли;
			КонецЕсли;
			Если Начало = Неопределено Тогда
				ТекущиеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания();
			Иначе
				ТекущиеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания(Новый Структура("Начало", Начало));
			КонецЕсли;
			
			// 2. Обновим совпадающие и вставим новые фоновые задания.
			//    Считаем, что список заданий отсортирован по убыванию колонки Начало.
			// 2.1. По ходу цикла проверим, что все задания в таблице со статусом Активно были получены с сервера.
			//      Если на сервере их уже по какой-то причине нет, тогда устанавливаем статус: Завершено.
			АктивныеЗадания = Таблица.НайтиСтроки(Новый Структура("Состояние", СостояниеФоновогоЗадания.Активно));
			НомерЗадания = ТекущиеФоновыеЗадания.Количество() - 1;
			Пока НомерЗадания >= 0 Цикл
				Задание = ТекущиеФоновыеЗадания[НомерЗадания];
				НайденныеСтроки = Таблица.НайтиСтроки(Новый Структура("Идентификатор, Начало", Строка(Задание.УникальныйИдентификатор), Задание.Начало));
				Если НайденныеСтроки.Количество() = 0 Тогда
					Строка = Таблица.Вставить(0);
					ТаблицаОбновлена = Истина;
				Иначе
					Строка = НайденныеСтроки[0];
					Если Строка.Состояние <> СостояниеФоновогоЗадания.Активно Тогда
						// Не имеет смысла обновлять те неактивные задания, которые уже
						// есть в таблице. Они попали в список повторно.
						НомерЗадания = НомерЗадания - 1;
						Продолжить;
					КонецЕсли;
					ТаблицаОбновлена = Истина;
					// Проверка активных задач в таблице, удаленных на сервере, путем удаления найденных из списка.
					АктивныеЗадания.Удалить(АктивныеЗадания.Найти(Строка));
				КонецЕсли;
				ЗаполнитьЗначенияСвойств(Строка, Задание);
				Строка.НаСервере = Истина;
				Строка.Идентификатор = Задание.УникальныйИдентификатор;
				Строка.ИдентификаторРегламентногоЗадания = ?(Задание.РегламентноеЗадание = Неопределено,
															  // Может быть уже установлен, если была обработка вручную.
															 Строка.ИдентификаторРегламентногоЗадания,
															 Задание.РегламентноеЗадание.УникальныйИдентификатор);
				Строка.ОписаниеИнформацииОбОшибке = ?(Задание.ИнформацияОбОшибке = Неопределено, "", ПодробноеПредставлениеОшибки(Задание.ИнформацияОбОшибке));
				НомерЗадания = НомерЗадания - 1;
			КонецЦикла;
			// 2.3. Сбросим состояние Активно для активных заданий в таблице, но не найденных на сервере.
			ТаблицаОбновлена = ТаблицаОбновлена ИЛИ АктивныеЗадания.Количество() > 0;
			Для каждого ПотерянноеАктивноеЗадание Из АктивныеЗадания Цикл
				ПотерянноеАктивноеЗадание.Состояние = СостояниеФоновогоЗадания.Завершено;
			КонецЦикла;
			
			// 3. Установим идентификаторы регламентных заданий тем фоновым заданиям, которые были выполнены вручную.
			//    И удалим несуществующие (устаревшие) соответствия.
			ЗапущенныеВручную = Состояние.Соответствие_ИФЗ_ИРЗ_ЗапущенныеНаСервереВручную;
			ТаблицаОбновлена = ТаблицаОбновлена ИЛИ ЗапущенныеВручную.Количество() > 0;
			
			МассивКлючейУдалить = Новый Массив;
			Для каждого КлючИЗначение из ЗапущенныеВручную Цикл
				Строка = Таблица.Найти(КлючИЗначение.Ключ, "Идентификатор");
				Если Строка = Неопределено Тогда
					МассивКлючейУдалить.Добавить(КлючИЗначение.Ключ);
				Иначе
					Строка.ИдентификаторРегламентногоЗадания = КлючИЗначение.Значение;
				КонецЕсли;
			КонецЦикла;
			Для каждого Ключ Из МассивКлючейУдалить Цикл
				ЗапущенныеВручную.Удалить(Ключ);
			КонецЦикла;

		КонецЕсли;
		// Почистим лишние задания (больше 1000).
		НомерЗадания = Таблица.Количество()-1;
		Пока НомерЗадания >= 1000 Цикл
			Таблица.Удалить(НомерЗадания);
			НомерЗадания = НомерЗадания - 1;
		КонецЦикла;
		Если ПрочитанноеСостояние = Неопределено Тогда
			Если ТаблицаОбновлена Тогда
				ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
				ЗафиксироватьТранзакцию();
			Иначе
				ОтменитьТранзакцию();
			КонецЕсли;
		Иначе
			Таблица = Таблица.Скопировать();
		КонецЕсли;
		ВсегоЗаданий = Таблица.Количество();
	Исключение
		Если ПрочитанноеСостояние = Неопределено Тогда
			ОтменитьТранзакцию();
		КонецЕсли;
		ВызватьИсключение;
	КонецПопытки;
	
	// Отбор фоновых заданий.
	Если Отбор <> Неопределено Тогда
		Начало 	  = Неопределено;
		Конец 	  = Неопределено;
		Состояние = Неопределено;
		Если Отбор.Свойство("Начало") Тогда
			Начало = ?(ЗначениеЗаполнено(Отбор.Начало), Отбор.Начало, Неопределено);
			Отбор.Удалить("Начало");
		КонецЕсли;
		Если Отбор.Свойство("Конец") Тогда
			Конец = ?(ЗначениеЗаполнено(Отбор.Конец), Отбор.Конец, Неопределено);
			Отбор.Удалить("Конец");
		КонецЕсли;
		Если Отбор.Свойство("Состояние") Тогда
			Если ТипЗнч(Отбор.Состояние) = Тип("Массив") Тогда
				Состояние = Отбор.Состояние;
				Отбор.Удалить("Состояние");
			КонецЕсли;
		КонецЕсли;
		Если Отбор.Количество() <> 0 Тогда
			Строки = Таблица.НайтиСтроки(Отбор);
		Иначе
			Строки = Таблица;
		КонецЕсли;
		// Выполним дополнительный фильтр по периоду и состоянию (если отбор определен).
		НомерЭлемента = Строки.Количество() - 1;
		Пока НомерЭлемента >= 0 Цикл
			Если Начало    <> Неопределено И Начало > Строки[НомерЭлемента].Начало ИЛИ
				 Конец     <> Неопределено И Конец  < ?(ЗначениеЗаполнено(Строки[НомерЭлемента].Конец), Строки[НомерЭлемента].Конец, ТекущаяДата()) ИЛИ
				 Состояние <> Неопределено И Состояние.Найти(Строки[НомерЭлемента].Состояние) = Неопределено Тогда
				Строки.Удалить(НомерЭлемента);
			КонецЕсли;
			НомерЭлемента = НомерЭлемента - 1;
		КонецЦикла;
		// Удалим лишние строки из таблицы.
		Если ТипЗнч(Строки) = Тип("Массив") Тогда
			НомерСтроки = ВсегоЗаданий - 1;
			Пока НомерСтроки >= 0 Цикл
				Если Строки.Найти(Таблица[НомерСтроки]) = Неопределено Тогда
					Таблица.Удалить(Таблица[НомерСтроки]);
				КонецЕсли;
				НомерСтроки = НомерСтроки - 1;
			КонецЦикла;
		КонецЕсли;
	КонецЕсли;
	
	Возврат Таблица;
	
КонецФункции // ПолучитьТаблицуСвойствФоновыхЗаданий()

// Функция возвращает свойства ФоновогоЗадания по строке уникального идентификатора.
//
// Параметры:
//  Идентификатор - Строка - уникального идентификатора ФоновогоЗадания.
//  ИменаСвойств  - Строка, если заполнено, возвращается структура с указанными свойствами.
//  ПрочитанноеСостояние - Неопределено, только для внутреннего использования.
// 
// Возвращаемое значение:
//  СтрокаТаблицыЗначений, Структура - свойства ФоновогоЗадания.
//
Функция ПолучитьСвойстваФоновогоЗадания(Идентификатор, ИменаСвойств = "", ПрочитанноеСостояние = Неопределено) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	Отбор = Новый Структура("Идентификатор", Идентификатор);
	ТаблицаСвойствФоновыхЗаданий = ПолучитьТаблицуСвойствФоновыхЗаданий(Отбор,, ПрочитанноеСостояние);
	
	Если ТаблицаСвойствФоновыхЗаданий.Количество() = 0 Тогда
		ВызватьИсключение( НСтр("ru = 'Фоновое задание не найдено!'") );
	КонецЕсли;
	
	Если ЗначениеЗаполнено(ИменаСвойств) Тогда
		Результат = Новый Структура(ИменаСвойств);
		ЗаполнитьЗначенияСвойств(Результат, ТаблицаСвойствФоновыхЗаданий[0]);
	Иначе
		Результат = ТаблицаСвойствФоновыхЗаданий[0];
	КонецЕсли;
	
	Возврат Результат;
	
КонецФункции // ПолучитьСвойстваФоновогоЗадания()

// Функция ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания возвращает
// свойства последнего фонового задания выполненного по регламентного заданию, если оно есть.
// Процедура работает, как в файл-серверном, так и в клиент-серверном режимах.
//
// Параметры:
//  РегламентноеЗадание - РегламентноеЗадание, Строка - строка уникального идентификатора РегламентногоЗадания.
//  ПрочитанноеСостояние - Неопределено, только для внутреннего использования.
//
// Возвращаемое значение:
//  СтрокаТаблицыЗначений, Неопределено.
//
Функция ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания(РегламентноеЗадание, ПрочитанноеСостояние = Неопределено) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	ИдентификаторРегламентногоЗадания = ?(ТипЗнч(РегламентноеЗадание) = Тип("РегламентноеЗадание"), Строка(РегламентноеЗадание.УникальныйИдентификатор), РегламентноеЗадание);
	ТаблицаСвойствФоновыхЗаданий = ПолучитьТаблицуСвойствФоновыхЗаданий(Новый Структура("ИдентификаторРегламентногоЗадания", ИдентификаторРегламентногоЗадания),, ПрочитанноеСостояние);
	ТаблицаСвойствФоновыхЗаданий.Сортировать("Конец Возр");
	
	Если ТаблицаСвойствФоновыхЗаданий.Количество() = 0 Тогда
		СвойстваФоновогоЗадания = Неопределено;
	ИначеЕсли НЕ ЗначениеЗаполнено(ТаблицаСвойствФоновыхЗаданий[0].Конец) Тогда
		СвойстваФоновогоЗадания = ТаблицаСвойствФоновыхЗаданий[0];
	Иначе
		СвойстваФоновогоЗадания = ТаблицаСвойствФоновыхЗаданий[ТаблицаСвойствФоновыхЗаданий.Количество()-1];
	КонецЕсли;
	
	Возврат СвойстваФоновогоЗадания;
	
КонецФункции // ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания()

// Процедура ОтменитьФоновоеЗадание отменяет фоновое задание, если
// это возможно, а именно, если оно выполняется на сервере, и активно.
//
// Параметры:
//  Идентификатор  - Строка уникального идентификатора ФоновогоЗадания.
// 
// Возвращаемое значение:
//  Булево       - НЕ Отказ.
//
Процедура ОтменитьФоновоеЗадание(Идентификатор) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	Если ПолучитьСвойстваФоновогоЗадания(Идентификатор, "Состояние").Состояние  <> СостояниеФоновогоЗадания.Активно Тогда
		ВызватьИсключение( НСтр("ru = 'Задание не выполняется, его нельзя отменить!'") );
		
	ИначеЕсли ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
		ВызватьИсключение( НСтр("ru ='Действие возможно только для серверной информационной базы!
									 |Невозможно отменить фоновое задание,
									 |выполняемое в сеансе файловой информационной базы!
									 |
									 |Если фоновое задание выполняется слишком долго и его нужно 
									 |непременно прекратить, закройте сеанс, в котором
									 |обрабатываются регламентные задания.
									 |
									 |Если сеанс не закрывается, а приложение не отвечает,
									 |можно снять его принудительно, однако есть риск
									 |потерять изменения выполненные в фоновом задании!'") );
	КонецЕсли;
	
	Отбор = Новый Структура("УникальныйИдентификатор", Новый УникальныйИдентификатор(Идентификатор));
	МассивФоновыхЗаданий = ФоновыеЗадания.ПолучитьФоновыеЗадания(Отбор);
	Если МассивФоновыхЗаданий.Количество() = 1 Тогда
		МассивФоновыхЗаданий[0].Отменить();
	Иначе
		ВызватьИсключение( НСтр("ru = 'Фоновое задание не найдено на сервере!'") );
	КонецЕсли;
	
КонецПроцедуры // ОтменитьФоновоеЗадание()

// Функция СообщенияИОписанияОшибокФоновогоЗадания возвращает
// многострочную Строку содержащую Сообщения и ОписаниеИнформацииОбОшибке,
// если фоновое задание найдено по идентификатору и сообщения/ошибки есть.
//
// Параметры:
//  Задание      - Строка - УникальныйИдентификатор ФоновогоЗадания строкой.
//
// Возвращаемое значение:
//  Строка.
//
Функция СообщенияИОписанияОшибокФоновогоЗадания(Идентификатор) Экспорт
	
	ВызватьИсключениеЕслиНетПраваАдминистрирования();
	
	СвойстваФоновогоЗадания = ПолучитьСвойстваФоновогоЗадания(Идентификатор);
	Строка = "";
	Для каждого Сообщение Из СвойстваФоновогоЗадания.СообщенияПользователю Цикл
		Строка = Строка + ?(Строка = "",
		                    Сообщение,
		                    "
		                    |
		                    |" + Сообщение);
	КонецЦикла;
	Если ЗначениеЗаполнено(СвойстваФоновогоЗадания.ОписаниеИнформацииОбОшибке) Тогда
		Строка = Строка + ?(Строка = "",
		                    СвойстваФоновогоЗадания.ОписаниеИнформацииОбОшибке,
		                    "
		                    |
		                    |" + СвойстваФоновогоЗадания.ОписаниеИнформацииОбОшибке);
	КонецЕсли;
	
	Возврат Строка;
	
КонецФункции // СообщенияИОписанияОшибокФоновогоЗадания()

// Процедура ОчиститьИсториюФоновыхЗаданий очищает таблицу
// хранения выполненных и выполняемых (в случае с серверным режимом) фоновых заданий.
//
Процедура ОчиститьИсториюФоновыхЗаданий() Экспорт

	ВызватьИсключениеЕслиНетПраваАдминистрирования();

	НачатьТранзакцию();
	Попытка
		Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий(Истина);
		Если ОбщегоНазначения.ИнформационнаяБазаФайловая() Тогда
			Состояние.ТаблицаФоновыхЗаданий = Неопределено;
		Иначе
			ТекущиеФоновыеЗадания = ФоновыеЗадания.ПолучитьФоновыеЗадания();
			Идентификаторы = Новый Соответствие;
			Для каждого ФоновоеЗадание Из ТекущиеФоновыеЗадания Цикл
				Идентификаторы.Вставить(Строка(ФоновоеЗадание.УникальныйИдентификатор), 1);
			КонецЦикла;
			Индекс = Состояние.ТаблицаФоновыхЗаданий.Количество()-1;
			Пока Индекс >=0 Цикл
				Если Идентификаторы.Получить(Состояние.ТаблицаФоновыхЗаданий[Индекс].Идентификатор) <> 1 Тогда
					Состояние.ТаблицаФоновыхЗаданий.Удалить(Индекс);
				КонецЕсли;
				Индекс = Индекс - 1;
			КонецЦикла;
		КонецЕсли;
		ПроверитьТаблицуФоновыхЗаданий(Состояние.ТаблицаФоновыхЗаданий);
		ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
КонецПроцедуры

////////////////////////////////////////////////////////////////////////////////
// СЛУЖЕБНЫЕ МЕТОДЫ ОБОБЩЕННОГО МЕНЕДЖЕРА ФОНОВЫХ ЗАДАНИЙ

// Функция ПроверитьТаблицуФоновыхЗаданий проверяет структуру ТаблицыЗначений
// для хранения выполненных/выполняемых фоновых заданий,
// и создает пустую таблицу, если есть различия.
//
// Параметры:
//  Таблица      - ТаблицаЗначений - таблица у которой будет проверяться структура.
//
// Возвращаемое значение:
//  Булево - когда Истина структура была правильная.
//
Функция ПроверитьТаблицуФоновыхЗаданий(Таблица)
	
	НоваяТаблица = Новый ТаблицаЗначений;
	НоваяТаблица.Колонки.Добавить("НаСервере", Новый ОписаниеТипов("Булево"));
	НоваяТаблица.Колонки.Добавить("Идентификатор", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("Наименование", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("Ключ", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("Начало", Новый ОписаниеТипов("Дата"));
	НоваяТаблица.Колонки.Добавить("Конец", Новый ОписаниеТипов("Дата"));
	НоваяТаблица.Колонки.Добавить("ИдентификаторРегламентногоЗадания", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("Состояние", Новый ОписаниеТипов("СостояниеФоновогоЗадания"));
	НоваяТаблица.Колонки.Добавить("ИмяМетода", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("Расположение", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("ОписаниеИнформацииОбОшибке", Новый ОписаниеТипов("Строка"));
	НоваяТаблица.Колонки.Добавить("ПопыткаЗапуска", Новый ОписаниеТипов("Число"));
	НоваяТаблица.Колонки.Добавить("СообщенияПользователю", Новый ОписаниеТипов("Массив"));
	НоваяТаблица.Индексы.Добавить("Идентификатор, Начало");
	СтруктураПравильная = Истина;
	Если ТипЗнч(Таблица) = Тип("ТаблицаЗначений") Тогда
		Для каждого Колонка Из НоваяТаблица.Колонки Цикл
			// Будем проводить только проверку наличия имен колонок без проверки типов.
			Если Таблица.Колонки.Найти(Колонка.Имя) = Неопределено Тогда
				СтруктураПравильная = Ложь;
			КонецЕсли;
		КонецЦикла;
	Иначе
		СтруктураПравильная = Ложь;
	КонецЕсли;
	
	Если НЕ СтруктураПравильная Тогда
		Таблица = НоваяТаблица;
	КонецЕсли;
	
	Возврат СтруктураПравильная;
	
КонецФункции // ПроверитьТаблицуФоновыхЗаданий()

// Функция ОбновитьНастройки служит для заполнения/восстановления структуры свойств
// настроек, хранимых в структуре "Состояние" свойства Настройки.
//
// Параметры:
//  Настройки - Неопределено, Структура.
//
// Возвращаемое значение:
//  Структура - обновленные настройки.
//
Функция ОбновитьНастройки(Знач Настройки = Неопределено)
	
	НоваяСтруктураНастроек = Новый Структура();
	НоваяСтруктураНастроек.Вставить("БлокировкаОбработкиРегламентныхЗаданий",                           Ложь);
	// Если нужно и можно, то при запуске клиентского приложения автоматически открывать сеанс обработки регламентных заданий.
	НоваяСтруктураНастроек.Вставить("АвтоматическиОткрыватьОтдельныйСеансОбработкиРегламентныхЗаданий", Ложь);
	// Если задания не обрабатываются или обработка "висит", уведомлять пользователя.
	НоваяСтруктураНастроек.Вставить("УведомлятьОНекорректномСостоянииОбработкиРегламентныхЗаданий",     Ложь);
	//  Период, минут.
	НоваяСтруктураНастроек.Вставить("ПериодУведомленияОСостоянииОбработкиРегламентныхЗаданий",          15);
	
	// Копирование существующих свойств.
	Если ТипЗнч(Настройки) = Тип("Структура") Тогда
		Для каждого КлючИзначение Из НоваяСтруктураНастроек Цикл
			Если Настройки.Свойство(КлючИзначение.Ключ) Тогда
				Если ТипЗнч(НоваяСтруктураНастроек[КлючИзначение.Ключ]) = ТипЗнч(Настройки[КлючИзначение.Ключ]) Тогда
					НоваяСтруктураНастроек[КлючИзначение.Ключ] = Настройки[КлючИзначение.Ключ];
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	Если НЕ (НоваяСтруктураНастроек.ПериодУведомленияОСостоянииОбработкиРегламентныхЗаданий >= 1 И
	         НоваяСтруктураНастроек.ПериодУведомленияОСостоянииОбработкиРегламентныхЗаданий <= 99 ) Тогда
	
		НоваяСтруктураНастроек.ПериодУведомленияОСостоянииОбработкиРегламентныхЗаданий = 15;
	КонецЕсли;
	
	Возврат НоваяСтруктураНастроек;
	
КонецФункции

// Функция ПолучитьСостояниеОбработкиРегламентныхЗаданий возвращает
// структуру, описывающую состояние обработки заданий.
//
Функция ПолучитьСостояниеОбработкиРегламентныхЗаданий(Заблокировать = Ложь)
	
	// Подготовка данных для проверки или начальной установки свойств прочитанного состояния.
	НоваяСтруктура = Новый Структура();
	НоваяСтруктура.Вставить("Настройки", Новый Структура);
	//  Соответствие идентификаторов фоновых заданий идентификаторам регламентных заданий,
	//  тех фоновых заданий, которые были запущены на сервере вручную.
	НоваяСтруктура.Вставить("Соответствие_ИФЗ_ИРЗ_ЗапущенныеНаСервереВручную", Новый Соответствие());
	// Хранение истории выполнения фоновых заданий.
	НоваяСтруктура.Вставить("ТаблицаФоновыхЗаданий",               Новый ТаблицаЗначений);
	НоваяСтруктура.Вставить("НомерСеанса",                         0);
	НоваяСтруктура.Вставить("НачалоСеанса",                        '00010101');
	НоваяСтруктура.Вставить("ИмяКомпьютера",                       "");
	НоваяСтруктура.Вставить("ИмяПриложения",                       "");
	НоваяСтруктура.Вставить("ИмяПользователя",                     "");
	НоваяСтруктура.Вставить("ИдентификаторОчередногоЗадания",      "");
	НоваяСтруктура.Вставить("НачалоОбработкиОчередногоЗадания",    '00010101');
	НоваяСтруктура.Вставить("ОкончаниеОбработкиОчередногоЗадания", '00010101');
	
	Если Заблокировать Тогда
		Блокировка = Новый БлокировкаДанных;
		Элемент = Блокировка.Добавить("Константа.СостояниеОбработкиРегламентныхЗаданий");
		Элемент.Режим = РежимБлокировкиДанных.Исключительный;
		Блокировка.Заблокировать();
	КонецЕсли;
	
	Состояние = Константы.СостояниеОбработкиРегламентныхЗаданий.Получить().Получить();
	
	// Копирование существующих свойств.
	Если ТипЗнч(Состояние) = Тип(НоваяСтруктура) Тогда
		Для каждого КлючИзначение Из НоваяСтруктура Цикл
			Если Состояние.Свойство(КлючИзначение.Ключ) Тогда
				Если ТипЗнч(НоваяСтруктура[КлючИзначение.Ключ]) = ТипЗнч(Состояние[КлючИзначение.Ключ]) Тогда
					НоваяСтруктура[КлючИзначение.Ключ] = Состояние[КлючИзначение.Ключ];
				КонецЕсли;
			КонецЕсли;
		КонецЦикла;
	КонецЕсли;
	
	НоваяСтруктура.Настройки = ОбновитьНастройки(НоваяСтруктура.Настройки);
	
	ПроверитьТаблицуФоновыхЗаданий(НоваяСтруктура.ТаблицаФоновыхЗаданий);
	
	Возврат НоваяСтруктура;
	
КонецФункции

// Процедура ОбновитьСостояниеОбработкиРегламентныхЗаданий() сохраняет
// в константе СостояниеОбработкиРегламентныхЗаданий переданное состояние.
//
// Параметры:
//  Состояние - Структура - изменённое значение функции
//                 ПолучитьСостояниеОбработкиРегламентныхЗаданий().
//  ИзмененныеСвойства - Неопределено, Строка;
//                       Неопределено - требуется записать состояние (есть внешняя транзакция);
//                       Строка       - список имен свойств, разделенный запятыми,
//                                      которые необходимо обновить в отдельной транзакции.
//
Процедура ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние, Знач ИзмененныеСвойства = Неопределено)
	
	Если ИзмененныеСвойства = Неопределено Тогда
		Константы.СостояниеОбработкиРегламентныхЗаданий.Установить(Новый ХранилищеЗначения(Состояние));
	Иначе
		НачатьТранзакцию();
		Попытка
			ТекущееСостояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий(Истина);
			ЗаполнитьЗначенияСвойств(ТекущееСостояние, Состояние, ИзмененныеСвойства);
			Состояние = ТекущееСостояние;
			Константы.СостояниеОбработкиРегламентныхЗаданий.Установить(Новый ХранилищеЗначения(Состояние));
			ЗафиксироватьТранзакцию();
		Исключение
			ОтменитьТранзакцию();
			ВызватьИсключение;
		КонецПопытки;
	КонецЕсли;
	
КонецПроцедуры // ОбновитьСостояниеОбработкиРегламентныхЗаданий()

// Процедура ОбработатьРегламентноеЗадание предназначена
// только для режима "файл-сервер", используется в процедуре
// ОбработатьРегламентныеЗадания()
// 
// Параметры:
//  Состояние    - Структура.
//  Задание      - РегламентноеЗадание.
//  ЗапускВручную - Булево.
//  МоментЗапуска - Неопределено, Дата(дата и время).Устанавливает значение, к момент запуска.
//  ИдентификаторФоновогоЗадания - Строка - идентификатор запущенного фонового задания.
//
Процедура ОбработатьРегламентноеЗадание(Знач Задание,
                                        Знач ЗапускВручную = Ложь,
                                        Знач МоментЗапуска = Неопределено,
                                        ИдентификаторФоновогоЗадания = "")

	НачатьТранзакцию();
	Попытка
		Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий(Истина);
		СвойстваПоследнегоФоновогоЗадания = ПолучитьСвойстваПоследнегоФоновогоЗаданияОбработкиРегламентногоЗадания(Задание, Состояние);

		ИмяМетода = Задание.Метаданные.ИмяМетода;
		НаименованиеФоновогоЗадания = ?(ЗапускВручную,
		                                СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(НСтр("ru = 'Запуск вручную: %1'"),
		                                                                                        ПредставлениеРегламентногоЗадания(Задание)),
		                                "");

		МоментЗапуска = ?(ТипЗнч(МоментЗапуска) <> Тип("Дата") ИЛИ НЕ ЗначениеЗаполнено(МоментЗапуска),
		                  ТекущаяДата(),
		                  МоментЗапуска);
		Таблица = Состояние.ТаблицаФоновыхЗаданий;
		// Создадим новое фоновое задание в таблице.
		СвойстваФоновогоЗадания = Таблица.Вставить(0);
		СвойстваФоновогоЗадания.Идентификатор  = Строка(Новый УникальныйИдентификатор());
		ИдентификаторФоновогоЗадания = СвойстваФоновогоЗадания.Идентификатор;
		СвойстваФоновогоЗадания.ПопыткаЗапуска = ?(СвойстваПоследнегоФоновогоЗадания <> Неопределено И
		                                           СвойстваПоследнегоФоновогоЗадания.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно,
		                                           СвойстваПоследнегоФоновогоЗадания.ПопыткаЗапуска + 1,
		                                  1);
		СвойстваФоновогоЗадания.Наименование   = НаименованиеФоновогоЗадания;
		СвойстваФоновогоЗадания.ИдентификаторРегламентногоЗадания
		                                       = Строка(Задание.УникальныйИдентификатор);
		СвойстваФоновогоЗадания.Расположение = "\\" + ИмяКомпьютера();
		СвойстваФоновогоЗадания.ИмяМетода    = ИмяМетода;
		СвойстваФоновогоЗадания.Состояние    = СостояниеФоновогоЗадания.Активно;
		СвойстваФоновогоЗадания.Начало       = МоментЗапуска;
		// Подготовка команды для выполнения метода вместо фонового задания.
		СтрокаПараметров = "";
		Индекс = Задание.Параметры.Количество()-1;
		Пока Индекс >= 0 Цикл
			Если НЕ ПустаяСтрока(СтрокаПараметров) Тогда
				СтрокаПараметров = СтрокаПараметров + ", ";
			КонецЕсли;
			СтрокаПараметров = СтрокаПараметров + "Задание.Параметры[" + Индекс + "]";
			Индекс = Индекс - 1;
		КонецЦикла;
		//
		ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
		ЗафиксироватьТранзакцию();
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	ПолучитьСообщенияПользователю(Истина);
	Попытка
		Выполнить("" + ИмяМетода + "(" + СтрокаПараметров + ");");
		СвойстваФоновогоЗадания.Состояние = СостояниеФоновогоЗадания.Завершено;
	Исключение
		СвойстваФоновогоЗадания.Состояние = СостояниеФоновогоЗадания.ЗавершеноАварийно;
		СвойстваФоновогоЗадания.ОписаниеИнформацииОбОшибке = ПодробноеПредставлениеОшибки(ИнформацияОбОшибке());
	КонецПопытки;
	// Зафиксируем окончание выполнения метода.
	СвойстваФоновогоЗадания.Конец = ТекущаяДата();
	СвойстваФоновогоЗадания.СообщенияПользователю = ПолучитьСообщенияПользователю(Истина);
	
	// Обновление свойств состояния.
	НачатьТранзакцию();
	Попытка
		Состояние = ПолучитьСостояниеОбработкиРегламентныхЗаданий(Истина);
		ТекущиеСвойстваФоновогоЗадания = Состояние.ТаблицаФоновыхЗаданий.Найти(СвойстваФоновогоЗадания.Идентификатор, "Идентификатор");
		Если ТекущиеСвойстваФоновогоЗадания <> Неопределено Тогда
			ЗаполнитьЗначенияСвойств(ТекущиеСвойстваФоновогоЗадания,
			                         СвойстваФоновогоЗадания,
			                         "Состояние,
			                         |ОписаниеИнформацииОбОшибке,
			                         |Конец,
			                         |СообщенияПользователю");
			ОбновитьСостояниеОбработкиРегламентныхЗаданий(Состояние);
			ЗафиксироватьТранзакцию();
		Иначе
			// Если в процессе выполнения была очищена таблица фоновых заданий, обновление состояния не требуется.
			ОтменитьТранзакцию();
		КонецЕсли;
	Исключение
		ОтменитьТранзакцию();
		ВызватьИсключение;
	КонецПопытки;
	
	
КонецПроцедуры // ОбработатьРегламентноеЗадание()
